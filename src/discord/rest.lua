local discord = require("discord.module")
local json = require("cjson")

local date = require("date")
local ltn12 = require("ltn12")
local socket = require("socket")
local http = require("copas.http")
local multipart = require("multipart")

local _M = { }
_M.BASE_URL = "https://discordapp.com/api%s"
_M.API_VERSION = 6

http.TIMEOUT = 60
http.USERAGENT = ("DiscordBot (%s, %s)"):format(discord._URL, discord._VERSION)

local handleRatelimits, request do
	local function createEndpoint(endpoint, ...)
		if _M.API_VERSION <= 4 then
			return _M.BASE_URL:format(("%s?v=%d"):format(endpoint:format(...), _M.API_VERSION))
		else
			return _M.BASE_URL:format(("/v%s%s"):format(_M.API_VERSION, endpoint:format(...)))
		end
	end

	local ratelimits = { }
	local globalRatelimit = { }
	function handleRatelimits(route)
		if globalRatelimit.active then
			if (os.time() - endpointLimits.start) > endpointLimits.reset then
				globalRatelimit.active = false
			else
				return nil, "global ratelimit enforced"
			end
		end

		local endpointLimits = ratelimits[route]
		if endpointLimits then
			if (os.time() - endpointLimits.start) > endpointLimits.reset then
				endpointLimits.remaining = endpointLimits.limit
			end

			if endpointLimits.remaining - 1 < 0 then
				return nil, "pre-emptive ratelimit"
			end
		else
			-- new endpoint, treat it as if we haven't requested before
			ratelimits[route] = {remaining=0,limit=0,reset=0,start=0}
		end

		return true
	end

	local function parseHttpDate(str)
		return date.diff(date(str), date.epoch()):spanseconds()
	end

	local cookies = { }
	function request(method, route, token, payload, contentType)
		local resp = {}
		local reqt = {
			method = method,
			sink = ltn12.sink.table(resp),
			headers = {
				["content-type"] = contentType or "application/json",
				authorization = token,
				cookie = table.concat(cookies, ";")
			}
		}

		local builtRoute = route
		if type(route) == "table" then
			builtRoute = route[1]:format(unpack(route, 2, #route))
			reqt.url = createEndpoint(builtRoute, unpack(route, 2, #route))
		else
			reqt.url = createEndpoint(builtRoute)
		end

		local ok, err = handleRatelimits(builtRoute)
		if not ok then return nil, err end

		if payload then
			reqt.headers["content-length"] = #payload
			reqt.source = ltn12.source.string(payload)
		end

		local succ, code, headers = http.request(reqt)

		if headers then
			local new_cookies = headers["set-cookie"]
			if new_cookies then
				cookies[#cookies+1] = new_cookies
			end

			local limit = headers["x-ratelimit-limit"]
			local remaining = headers["x-ratelimit-remaining"]
			local reset = headers["x-ratelimit-reset"]
			local global = headers["x-ratelimit-global"]
			local retryAfter = headers["retry-after"]
			local httpDate = parseHttpDate(headers["date"])

			if global == "true" then
				globalRatelimit.start = os.time()
				globalRatelimit.reset = os.difftime(tonumber(retryAfter), httpDate)
				globalRatelimit.active = true
			end

			if limit and remaining and reset then
				local limits = ratelimits[builtRoute]
				limits.remaining = tonumber(remaining)
				limits.start = os.time()
				limits.reset = os.difftime(tonumber(reset), httpDate)
				limits.limit = tonumber(limit)
			end
		end

		resp = table.concat(resp, "")

		local succ, data = pcall(json.decode, resp)
		return succ, data, code, headers
	end
end

-- TODO: this should be autogenerated based on a table of endpoints

function _M.getGateway(token)
	return request("GET", "/gateway", token)
end

function _M.getGatewayBot(token)
	return request("GET", "/gateway/bot", token)
end

function _M.getChannel(token, channel)
	return request("GET", {"/channels/%s", channel}, token)
end

function _M.modifyChannel(token, channel, payload)
	return request("PATCH", {"/channels/%s", channel}, token, json.encode(payload))
end

function _M.deleteChannel(token, channel)
	return request("DELETE", {"/channels/%s", channel}, token)
end

function _M.getChannelMessages(token, channel, query)
	return request("GET", {"/channels/%s%%s", channel, "?", query}, token)
end

function _M.getChannelMessage(token, channel, message)
	return request("GET", {"/channels/%s/messages/%%s", channel, message}, token)
end

function _M.createMessage(token, channel, payload)
	return request("POST", {"/channels/%s/messages", channel}, token, json.encode(payload))
end

function _M.uploadFile(token, channel, payload)
	return error("not yet implemented", 2)
	--[[
	local data = multipart.new()
	data._boundary = string.format("%s%s", string.rep("-", 10), socket.gettime() * 10000)
	local contentType = string.format("multipart/form-data; boundary=%s", data._boundary)

	for i, v in pairs(payload) do
		if i == "file" then
			data:set_file(i, v.name, v.contents)
		else
			data:set_simple(i, v)
		end
	end

	return request("POST", {"/channels/%s/messages", channel}, token, data:tostring(), contentType)
	]]
end

function _M.editMessage(token, channel, message, payload)
	return request("PATCH", {"/channels/%s/messages/%%s", channel, message}, token, json.encode(payload))
end

function _M.deleteMessage(token, channel, message)
	return request("DELETE", {"/channels/%s/messages/%%s", channel, message}, token)
end

function _M.bulkDeleteMessages(token, channel, messages)
	return request("POST", {"/channels/%s/messages/bulk-delete", channel}, token, json.encode(messages))
end

function _M.editChannelPermissions(token, channel, overwrite, payload)
	return request("PUT", {"/channels/%s/permissions/%%s", channel, overwrite}, token, json.encode(payload))
end

function _M.getChannelInvites(token, channel)
	return request("GET", {"/channels/%s/invites", channel}, token)
end

function _M.createChannelInvite(token, channel, payload)
	return request("GET", {"/channels/%s/invites", channel}, token, json.encode(payload))
end

function _M.deleteChannelPermission(token, channel, overwrite)
	return request("DELETE", {"/channels/%s/permissions/%%s", channel, overwrite}, token)
end

function _M.triggerTypingIndicator(token, channel)
	return request("POST", {"/channels/%s/typing", channel}, token)
end

function _M.getPinnedMessages(token, channel)
	return request("GET", {"/channels/%s/pins", channel}, token)
end

function _M.addPinnedChannelMessage(token, channel, message)
	return request("PUT", {"/channels/%s/pins/%%s", channel, message}, token)
end

function _M.deletePinnedChannelMessage(token, channel, message)
	return request("DELETE", {"/channels/%s/pins/%%s", channel, message}, token)
end

function _M.groupDMAddRecipient(token, channel, user)
	return request("PUT", {"/channels/%s/recipients/%%s", channel, user}, token)
end

function _M.groupDMRemoveRecipient(token, channel, user)
	return request("DELETE", {"/channels/%s/recipients/%%s", channel, user}, token)
end

function _M.createGuild(token, payload)
	return request("POST", {"/guilds"}, token, json.encode(payload))
end

function _M.getGuild(token, guild)
	return request("GET", {"/guilds/%s", guild}, token)
end

function _M.modifyGuild(token, guild, payload)
	return request("PATCH", {"/guilds/%s", guild}, token, json.encode(payload))
end

function _M.deleteGuild(token, guild)
	return request("DELETE", {"/guilds/%s", guild}, token)
end

function _M.getGuildChannels(token, guild)
	return request("GET", {"/guilds/%s/channels", guild}, token)
end

function _M.createGuildChannel(token, guild, payload)
	return request("POST", {"/guilds/%s/channels", guild}, token, json.encode(payload))
end

function _M.modifyGuildChannelPosition(token, guild, payload)
	return request("PATCH", {"/guilds/%s/channels", guild}, token, json.encode(payload))
end

function _M.getGuildMember(token, guild, user)
	return request("GET", {"/guilds/%s/members/%%s", guild, user}, token)
end

function _M.listGuildMembers(token, guild, query)
	return request("GET", {"/guilds/%s/members%%s", guild, query}, token)
end

function _M.addGuildMember(token, guild, user, payload)
	return request("PUT", {"/guilds/%s/members/%%s", guild, user}, token, json.encode(payload))
end

function _M.modifyGuildMember(token, guild, user, payload)
	return request("PATCH", {"/guilds/%s/members/%%s", guild, user}, token, json.encode(payload))
end

function _M.removeGuildMember(token, guild, user)
	return request("DELETE", {"/guilds/%s/members/%%s", guild, user}, token)
end

function _M.getGuildBans(token, guild)
	return request("GET", {"/guilds/%s/bans", guild}, token)
end

function _M.createGuildBans(token, guild, user, payload)
	return request("PUT", {"/guilds/%s/bans/%%s", guild, user}, token, json.encode(payload))
end

function _M.removeGuildBan(token, guild, user)
	return request("DELETE", {"/guilds/%s/bans/%%s", guild, user}, token)
end

function _M.getGuildRoles(token, guild)
	return request("GET", {"/guilds/%s/roles", guild}, token)
end

function _M.createGuildRole(token, guild)
	return request("POST", {"/guilds/%s/roles", guild}, token)
end

function _M.batchModifyGuildRole(token, guild, payload)
	return request("PATCH", {"/guilds/%s/roles", guild}, token, json.encode(payload))
end

function _M.modifyGuildRole(token, guild, role, payload)
	return request("PATCH", {"/guilds/%s/roles/%%s", guild, role}, token, json.encode(payload))
end

function _M.deleteGuildRole(token, guild, role)
	return request("DELETE", {"/guilds/%s/roles/%%s", guild, role}, token)
end

function _M.getGuildPruneCount(token, guild, days)
	return request("GET", {"/guilds/%s/prune%%s%%s", guild, "?days=", days}, token)
end

function _M.beginGuildPrune(token, guild, days)
	return request("POST", {"/guilds/%s/prune%%s%%s", guild, "?days=", days}, token)
end

function _M.getGuildVoiceRegions(token, guild)
	return request("GET", {"/guilds/%s/regions", guild}, token)
end

function _M.getGuildInvites(token, guild)
	return request("GET", {"/guilds/%s/invites", guild}, token)
end

function _M.getGuildIntegrations(token, guild)
	return request("GET", {"/guilds/%s/integrations", guild}, token)
end

function _M.createGuildIntegration(token, guild, payload)
	return request("POST", {"/guilds/%s/integrations", guild}, token, json.encode(payload))
end

function _M.modifyGuildIntegration(token, guild, integration, payload)
	return request("PATCH", {"/guilds/%s/integrations/%%s", guild, integration}, token, json.encode(payload))
end

function _M.deleteGuildIntegrations(token, guild, integration)
	return request("GET", {"/guilds/%s/integrations/%%s", guild, integration}, token)
end

function _M.syncGuildIntegrations(token, guild)
	return request("POST", {"/guilds/%s/integrations", guild}, token)
end

function _M.getGuildEmbed(token, guild)
	return request("GET", {"/guilds/%s/embed", guild}, token)
end

function _M.modifyGuildEmbed(token, guild, payload)
	return request("PATCH", {"/guilds/%s/embed", guild}, token, json.encode(payload))
end

function _M.getInvite(token, code)
	return request("GET", {"/invites/%%s", code}, token)
end

function _M.deleteInvite(token, code)
	return request("DELETE", {"/invites/%%s", code}, token)
end

function _M.acceptInvite(token, code)
	return request("POST", {"/invites/%%s", code}, token)
end

function _M.getCurrentUser(token)
	return request("GET", "/users/@me", token)
end

function _M.getCurrentUser(token, user)
	return request("GET", {"/users/%%s", user}, token)
end

function _M.modifyCurrentUser(token, payload)
	return request("PATCH", "/users/@me", token, json.encode(payload))
end

function _M.getCurrentUserGuilds(token)
	return request("GET", "/users/@me/guilds", token)
end

function _M.leaveGuild(token, guild)
	return request("DELETE", {"/users/@me/guilds/%s", guild}, token)
end

function _M.getUserDMs(token)
	return request("GET", "/users/@me/channels", token)
end

function _M.createDM(token, recipient)
	return request("POST", "/users/@me/channels", token, json.encode{recipient_id=recipient})
end

function _M.createGroupDM(token, payload)
	return request("POST", "/users/@me/channels", token, json.encode(payload))
end

function _M.getUsersConnections(token)
	return request("GET", "/users/@me/connections", token)
end

function _M.listVoiceRegions(token)
	return request("GET", "/voice/regions", token)
end

function _M.createWebhook(token, channel, payload)
	return request("POST", {"/channels/%s/webhooks", channel}, token, json.encode(payload))
end

function _M.getChannelWebhooks(token, channel)
	return request("GET", {"/channels/%s/webhooks", channel}, token)
end

function _M.getGuildWebhook(token, guild)
	return request("GET", {"/guilds/%s/webhooks", guild}, token)
end

function _M.getWebhookWithToken(webhook, webhookToken)
	return request("GET", {"/webhooks/%%s/%%s", webhook, webhookToken})
end

function _M.modifyWebhook(token, webhook, payload)
	return request("PATCH", {"/webhooks/%%s", webhook}, token, json.encode(payload))
end

function _M.modifyWebhookWithToken(webhook, webhookToken, payload)
	return request("PATCH", {"/webhooks/%%s/%%s", webhook, webhookToken}, nil, json.encode(payload))
end

function _M.deleteWebhook(token, webhook)
	return request("DELETE", {"/webhooks/%%s", webhook}, token)
end

function _M.deleteWebhookWithToken(webhook, webhookToken)
	return request("DELETE", {"/webhooks/%%s/%%s", webhook, webhookToken})
end

return _M